The main entrypoint is
\href{https://github.com/yurrriq/dotfiles/blob/main/flake.nix}{flake.nix},
which defines a \hrefootnote{https://nixos.wiki/wiki/Flakes}{Nix Flake}.

At the top-level, the flake defines \hyperref[sec:inputs]{\nix{inputs}} and
\hyperref[sec:outputs]{\nix{outputs}}.

<<flake.nix>>=
{

  description = "My (semi-)literate, Nix-based dotfiles";

  inputs = {
    <<inputs>>
  };

  outputs = { self, ... }@inputs:
    let
      inherit (inputs.nixpkgs) lib;
      <<outputs variables>>
    in
    {
      <<outputs>>
    };

}
@

\section{Inputs}
\label{sec:inputs}

\subsection{deadnix}

\todoo{Describe deadnix}

<<inputs>>=
deadnix = {
  url = "github:astro/deadnix";
  inputs.nixpkgs.follows = "nixpkgs";
};
@

\subsection{emacs-overlay}
\label{subsec:inputs-emacs-overlay}

The \hrefootnote{https://github.com/nix-community/emacs-overlay}{Emacs overlay}
\say{comes with extra functions to generate an Emacs closure from various types
  of dependency declaration.} Notably, \nix{emacsWithPackagesFromUsePackage},
which generates an Emacs closure from an Emacs config file, by way of
\hrefootnote{https://jwiegley.github.io/use-package/}{\elisp{use-package}}.  See
\hyperref[sec:emacs]{the Emacs section} on page~\pageref{sec:emacs} for usage.

<<inputs>>=
emacs-overlay = {
  url = "github:nix-community/emacs-overlay";
  inputs.flake-utils.follows = "flake-utils";
  inputs.nixpkgs.follows = "nixpkgs";
};
@

\subsection{flake-utils}

\todoo{Describe flake-utils}
<<inputs>>=
flake-utils.url = "github:numtide/flake-utils";
@


\subsection{home-manager}

\hrefootnote{https://github.com/nix-community/home-manager}{home-manager} is an
invaluable tool for managing a deterministic \bash{$HOME}.

<<inputs>>=
home-manager = {
  url = "github:nix-community/home-manager";
  inputs.nixpkgs.follows = "nixpkgs";
  inputs.utils.follows = "flake-utils";
};
@

\subsection{nixGL}

\todoo{Describe nixGL}

<<inputs>>=
nixgl = {
  url = "github:guibou/nixGL";
  inputs.flake-utils.follows = "flake-utils";
  inputs.nixpkgs.follows = "nixpkgs";
};
@

\subsection{nixos-hardware}

\hrefootnote{https://github.com/NixOS/nixos-hardware}{nixos-hardware} is
\say{a collection of NixOS modules covering hardware quirks.}

<<inputs>>=
nixos-hardware.url = "github:nixos/nixos-hardware";
@

\subsection{nixpkgs}

Prefer to live on the edge.

<<inputs>>=
nixpkgs.url = "github:nixos/nixpkgs/nixpkgs-unstable";
@

Of course, pin a stable version of the too
\hrefootnote{https://github.com/NixOS/nixpkgs}{Nix Packages collection}.

<<inputs>>=
nixpkgs-stable.url = "github:nixos/nixpkgs/release-22.11";
@

\subsection{NUR}

The \hrefootnote{https://github.com/nix-community/NUR}{Nix User Repository}
provides \say{user contributed Nix packages.} Notably, I use some of
\href{https://rycee.net}{Robert Helgesson}'s
\hrefootnote{https://gitlab.com/rycee/nur-expressions/-/blob/master/pkgs/firefox-addons/default.nix}{Firefox
  add-ons} (see \hyperref[sec:firefox]{Firefox} on page~\pageref{sec:firefox}).

<<inputs>>=
nur.url = "github:nix-community/nur";
@

\section{Outputs}
\label{sec:outputs}

\subsection{Overlays}

Use \nix{composeManyExtensions}\footnote{
  \say{%
    Compose several extending functions of the type expected by \nix{extends} into
    one where changes made in preceding functions are made available to subsequent
    ones.%
  } --- \href{https://github.com/NixOS/nixpkgs/commit/c3b35f21}{NixOS/nixpkgs@c3b35f21}%
} to compose all the [[<<overlays>>]] into one.

<<outputs>>=
overlay = lib.composeManyExtensions (lib.attrValues self.overlays);

overlays = {
  <<overlays>>
};
@

\subsection{Development environments}

Define some development environments, which Nix will cache, including an unnamed
default.  One of the main benefits is the super fast
\hrefootnote{https://direnv.net}{direnv} integration.

<<outputs>>=
devShells.x86_64-linux = {
  <<devShells x86_64-linux>>
};
@

Define the default \nix{devShell}, including tools to build
\hrefootnote{https://yurrriq.codes/dotfiles/dotfiles.pdf}{the PDF,}
\hrefootnote{https://github.com/mozilla/sops}{manage secrets},
\hrefootnote{https://linux.die.net/man/1/mkpasswd}{generate passwords},
\hrefootnote{https://github.com/fsaintjacques/semver-tool}{bump the version},
run \hrefootnote{https://github.com/nix-community/nixpkgs-fmt}{a}
\hrefootnote{https://github.com/mvdan/sh}{few}
\hrefootnote{https://www.shellcheck.net/}{linters} (with or without
\hrefootnote{https://pre-commit.com}{pre-commit}), and
\hrefootnote{https://www.gnu.org/software/stow/}{manage the non-Nix symlink
  farm}.

<<devShells x86_64-linux>>=
default = pkgs.mkShell {
  inherit (self.defaultPackage.x86_64-linux) FONTCONFIG_FILE;
  buildInputs = with pkgs; [
    biber
    deadnix
    git
    git-lfs
    gitAndTools.pre-commit
    gnumake
    gnupg
    home-manager
    mkpasswd
    nixpkgs-fmt
    nodePackages.node2nix
    semver-tool
    shellcheck
    shfmt
    sops
    stow
  ] ++ self.defaultPackage.x86_64-linux.nativeBuildInputs;
};
@

Configure a development environment for my
\hrefootnote{https://xmonad.org}{XMonad} config. Use the
\hyperref[subsec:inputs-emacs-overlay]{Emacs overlay} to configure a nice Emacs
setup using \hrefootnote{https://emacs-lsp.github.io/lsp-haskell/}{lsp-haskell},
\hrefootnote{https://github.com/tweag/ormolu}{Ormolu} to format Haskell code,
and include \hrefootnote{https://github.com/bmillwood/pointfree}{pointfree}
for... reasons.

<<devShells x86_64-linux>>=
xmonad =
  let
    _pkgs = import inputs.nixpkgs {
      overlays = [
        inputs.emacs-overlay.overlay
      ];
      system = "x86_64-linux";
    };
    myXMonad =
      _pkgs.haskellPackages.callCabal2nix "my-xmonad" ./config/xmonad { };
  in
  _pkgs.mkShell {
    buildInputs = with _pkgs; [
      cabal-install
      ghcid
      gitAndTools.pre-commit
      haskell-language-server
      haskellPackages.ormolu
      haskellPackages.pointfree
      (
        emacsWithPackagesFromUsePackage {
          alwaysEnsure = true;
          config = ./config/xmonad/emacs.el;
        }
      )
    ] ++ myXMonad.env.nativeBuildInputs;
  };
@

\subsection{Packages}

See also: \hyperref[chap:packages]{Packages}.

<<outputs>>=
packages.x86_64-linux = {
  fish-kubectl-completions = pkgs.callPackage ./pkgs/shells/fish/kubectl-completions { };
  yurrriq-dotfiles = pkgs.callPackage ./. { };
};

@

The default package builds
\hrefootnote{https://yurrriq.codes/dotfiles/dotfiles.pdf}{the PDF}.

<<outputs>>=
defaultPackage.x86_64-linux = self.packages.x86_64-linux.yurrriq-dotfiles;
@

\subsection{Modules}

See \hyperref[subsec:modules]{Modules}.

<<outputs>>=
nixosModules = {
  <<Modules>>
};
@

\subsection{NixOS configurations}

Define system configurations for \hyperref[sec:nixps]{my personal laptop} and
\hyperref[sec:sruxps]{my work laptop}.

<<outputs>>=
nixosConfigurations = {
  "nixps" = mkSystem "nixps" "dell-xps-15-9560-intel";
  "MSP-EBAILEY01" = mkSystem "sruxps" "dell-xps-13-7390";
};
@

\subsection{home-manager configurations}

\todoo{Describe this}

<<outputs>>=
homeConfigurations.eric = inputs.home-manager.lib.homeManagerConfiguration {
  modules = [
    # FIXME: There's gotta be a better way...
    (
      { pkgs, ... }@args:
      ((import ./machines/sruxps/home.nix) args) //
      self.nixosModules.nixRegistry
    )
    {
      home = {
        username = "eric";
        homeDirectory = "/home/eric";
        stateVersion = "22.11";
      };
    }
  ];
  pkgs = import inputs.nixpkgs {
    inherit (self.nixosModules.nixpkgs.nixpkgs) config;
    overlays = self.nixosModules.nixpkgs.nixpkgs.overlays ++ [
      # https://github.com/nix-community/home-manager/issues/2251#issuecomment-895338427
      (final: prev: {
        kitty = prev.lib.nixGLWrap { pkg = prev.kitty; };
        # FIXME
        # zoom-us = prev.lib.nixGLWrap { pkg = prev.zoom-us; binName = "zoom"; };
      })
    ];
    system = "x86_64-linux";
  };
};
@

\subsection{Variables}

Define a helper function, [[mkSystem]], for creating system configurations.
\todoo{Document \nix{mkSystem}}

\begin{minted}{haskell}
  mkSystem :: String -> String -> AttrSet
\end{minted}

<<outputs variables>>=
mkSystem = name: machine: lib.nixosSystem {
  modules = [
    (./machines + "/${name}/hardware-configuration.nix")
    inputs.nixos-hardware.nixosModules.${machine}
    inputs.nixos-hardware.nixosModules.common-pc-laptop-ssd
    inputs.home-manager.nixosModules.home-manager
    {
      home-manager = {
        useGlobalPkgs = true;
        useUserPackages = true;
        verbose = true;
      };
    }
    self.nixosModules.location
    self.nixosModules.nix
    self.nixosModules.nixPath
    self.nixosModules.nixRegistry
    self.nixosModules.nixos
    self.nixosModules.nixpkgs
    self.nixosModules.bootyjams
    self.nixosModules.virtualisation
    (./machines + "/${name}/configuration.nix")
  ];
  system = "x86_64-linux";
};
@

\todoo{Document \nix{pkgNameElem}}

<<outputs variables>>=
pkgNameElem = names: pkg:
  builtins.elem (lib.getName pkg) names;
@

\todoo{Document \nix{pkgs}}

<<outputs variables>>=
pkgs = import inputs.nixpkgs {
  overlays = [
    inputs.deadnix.overlays.default
    self.overlays.home-manager
    self.overlays.noweb
  ];
  system = "x86_64-linux";
};
@

\subsection{Overlays}

Define an overlay that adds [[fish-kubectl-completions]].\todor{Fix this noweb xref}

<<overlays>>=
fish-completions = final: prev: {
  fish-kubectl-completions = prev.callPackage ./pkgs/shells/fish/kubectl-completions { };
};
@

Define an overlay with a pinned version of home-manager.

<<overlays>>=
home-manager = final: prev: {
  home-manager = inputs.home-manager.packages.${prev.system}.home-manager;
};
@

\todoo{Describe this nixGL nonsense.}

<<overlays>>=
nixGLWrap = final: prev: {
  lib = prev.lib // {
    nixGLWrap = { pkg, binName ? prev.lib.getName pkg }:
      prev.writeShellScriptBin binName ''
        exec ${final.nixgl.nixGLIntel}/bin/nixGLIntel ${pkg}/bin/${binName} "$@"
      '';
  };
};
@

Define an overlay that adds \hyperref[sec:node-packages]{my custom
  \nix{nodePackages}}.

\begin{minted}{nix}
  nodePackages = final: prev: {
    nodePackages =
      unstable-pkgs.nodePackages // prev.callPackage ./pkgs/development/node-packages {
        inherit (prev) pkgs nodejs;
      };
  };
\end{minted}

Define an overlay that overrides
\hrefootnote{https://www.cs.tufts.edu/~nr/noweb/}{noweb} to build with a
non-graphical version of \hrefootnote{https://www2.cs.arizona.edu/icon/}{Icon}.

<<overlays>>=
noweb = final: prev: {
  noweb = prev.noweb.override {
    icon-lang = prev.icon-lang.override {
      withGraphics = false;
    };
  };
};
@

\subsection{NixOS Modules}
\label{subsec:modules}

\todoo{Document (or better yet: refactor) the other \nix{nixosModules}}

<<Modules>>=
bootyjams = import ./modules/bootyjams.nix;
location = import ./modules/location.nix;
nix = import ./modules/nix.nix;
@

\todoo{Document this \nix{nixPath} hack}

<<Modules>>=
nixPath = {
  nix.nixPath = lib.mapAttrsToList (n: v: "${n}=${v}")
    (lib.filterAttrs (n: _: n != "self") inputs) ++ [
    "nixos-config=/etc/nixos/configuration.nix"
  ];
};
@

\todoo{Document \nix{nixRegistry}}

<<Modules>>=
nixRegistry = {
  nix.registry = lib.mapAttrs (_: flake: { inherit flake; }) inputs;
};
@

<<Modules>>=
nixos = import ./modules/nixos.nix;
@

\todoo{Document \nix{nixpkgs} config}

<<Modules>>=
nixpkgs = {
  nixpkgs.config.allowUnfreePredicate = pkgNameElem [
    "Oracle_VM_VirtualBox_Extension_Pack"
    "lastpass-password-manager"
    "nvidia"
    "reaper"
    "slack"
    "spotify"
    "spotify-unwrapped"
    "steam"
    "steam-original"
    "steam-run"
    "zoom"
  ];
  nixpkgs.overlays = [
    self.overlay
    inputs.deadnix.overlays.default
    inputs.emacs-overlay.overlay
    inputs.nixgl.overlay
    inputs.nur.overlay
  ];
};
@

See \hyperref[sec:virtualisation]{Virtualisation}.

<<Modules>>=
virtualisation = import ./modules/virtualisation.nix;
@


%% Local Variables:
%% noweb-code-mode: nix-mode
%% End:
